import os
import requests
from PIL import Image
from io import BytesIO
from pytube import YouTube
import streamlit as st
import shutil
from datetime import datetime
import time
import geocoder
import cv2
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase
from email import encoders
from ultralytics import YOLO
from twilio.rest import Client
TWILIO_ACCOUNT_SID = os.getenv("TWILIO_ACCOUNT_SID")
TWILIO_AUTH_TOKEN = os.getenv("TWILIO_AUTH_TOKEN")


import concurrent.futures
def load_model(model_choice):
    if model_choice == 'Accident Detection':
        return YOLO("input\c.pt")
    elif model_choice == 'Weapon Detection':
        return YOLO("input\w.pt")
    elif model_choice == 'Fall Detection':
        return YOLO("input\Fall.pt")
    elif model_choice == 'Fire Detection':
        fire_model = YOLO("input\Fire.pt")
        car_model = YOLO("input\yolov8n.pt")
        return fire_model, car_model
    return None
email_info = {
    'sender_email': 'nameet1717@gmail.com',
    'sender_password': 'hudeooawfqxlfqnv',
    'recipient_email': 'nameet.7800@gmail.com',
    'subject': 'Anomaly Detection Alert',
    'text_content': """
        Anomaly Detected!
        This email is to inform you that our system has detected an anomaly. Please review the attached image for more details.
        Date and Time: {datetime}
        Location: Latitude - {latitude}, Longitude - {longitude}
        "https://www.google.com/maps/search/?api=1&query={latitude},{longitude}"
        For further investigation, please take appropriate actions accordingly.
""",
}
from twilio.rest import Client
TWILIO_ACCOUNT_SID = 'ACb7554eaaff15dfdf4cdddd978cdc3d27'
TWILIO_AUTH_TOKEN = 'b56a6c0ed94925579079123781edb7e3'
TWILIO_PHONE_NUMBER = '+17408833967'
RECIPIENT_PHONE_NUMBER = '+918928711770'
message = "Attention, authorities! This is an automated alert generated by our system. An anomaly has been detected and requires immediate attention. Please investigate the situation at your earliest convenience also an email is sent to you for more details. Thank you."
def make_phone_call(message):
    client = Client(TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN)
    call = client.calls.create(
        to=RECIPIENT_PHONE_NUMBER,
        from_=TWILIO_PHONE_NUMBER,
        method='GET',
        twiml=f'<Response><Say>{message}</Say></Response>'
    )
    print(f"Call SID: {call.sid}")
def detect_fire_objects(models, source):
    if models is not None and isinstance(models, tuple) and len(models) == 2:
        fire_model, car_model = models
        # Define a function to perform detection for the fire model
        def detect_fire(model, source):
            return model.predict(source=source, show=True, save=True, conf=0.8)
        # Execute detection tasks for both fire and car models concurrently
        with concurrent.futures.ThreadPoolExecutor() as executor:
            future_fire = executor.submit(detect_fire, fire_model, source)
            future_car = executor.submit(car_model.predict, source=source, show=False, save=False, conf=0.7)
            # Get the results of both detection tasks
            results_fire = future_fire.result()
            results_car = future_car.result()
        fire_detected = False
        car_detected = False
        # Check if fire is detected
        for result_fire in results_fire:
            if result_fire.boxes is not None and len(result_fire.boxes) > 0:
                fire_detected = True
                break
        # Check if car is detected
        for result_car in results_car:
            if result_car.boxes is not None and len(result_car.boxes) > 0:
                car_detected = True
                break
        # If both fire and car are detected, send email
        if fire_detected and car_detected:
            latitude = 19.12154590430884
            longitude = 72.823639193655
            send_email(email_info, source, latitude, longitude)
            make_phone_call(message) 
            if os.path.exists(source):
                os.remove(source)
            return True
    return False
def send_email(email_info, file_path, latitude=None, longitude=None):
    try:
        sender_email = email_info.get('sender_email')
        sender_password = email_info.get('sender_password')
        recipient_email = email_info.get('recipient_email')
        subject = email_info.get('subject')
        text_content = email_info.get('text_content')
        msg = MIMEMultipart()
        msg['Subject'] = subject
        msg['From'] = sender_email
        msg['To'] = recipient_email
        text = MIMEText(text_content.format(datetime=datetime.now(), latitude=latitude, longitude=longitude))
        msg.attach(text)
        with open(file_path, 'rb') as file:
            file_data = file.read()
        part = MIMEBase('application', "octet-stream")
        part.set_payload(file_data)
        encoders.encode_base64(part)
        part.add_header('Content-Disposition', f'attachment; filename="{os.path.basename(file_path)}"')
        msg.attach(part)
        with smtplib.SMTP('smtp.gmail.com', 587) as s:
            s.starttls()
            s.login(sender_email, sender_password)
            s.send_message(msg)
        print("Email sent successfully!")
    except Exception as e:
        print("Sending email:", str(e))
def detect_objects(model, choice, source):
    if model is not None:
        results_list = model.predict(source=source, show=True, save=True, conf=0.7)
        for results in results_list:
            if results.boxes is not None and len(results.boxes) > 0: 
                latitude = 19.12154590430884 
                longitude = 72.823639193655  
                send_email(email_info, source, latitude, longitude)
                make_phone_call(message) 
                if os.path.exists(source):
                    os.remove(source)
                return True
        else:
            return False
def detect_objects_webcam(model):
    location = geocoder.ip('me')
    latitude, longitude = location.latlng
    map_opened = False
    detected = False
    last_write_time = time.time()
    initial_detection_time = None
    cap = cv2.VideoCapture(0)
    while cap.isOpened():
        ret, frame = cap.read()
        if not ret:
            break
        results = model.predict(frame)
        for result in results:
            if result.boxes is not None and len(result.boxes.data) > 0: 
                confidence = result.boxes.conf[0] 
                if confidence > 0.7 and not detected: 
                    current_time = datetime.now().strftime("%H:%M:%S")
                    print(f"Object detected at latitude: {latitude}, longitude: {longitude}, time: {current_time}")
                    annotate_frame(frame, latitude, longitude)
                    if not map_opened:
                        open_google_maps(latitude, longitude)
                        map_opened = True
                    detected = True
                    initial_detection_time = time.time()
                    send_email(email_info, frame, latitude, longitude, source_type='Webcam')
                    make_phone_call(message) 
        cv2.imshow('Object Detection', frame)
        if detected and time.time() - last_write_time >= 15:
            st.write(f"Object detected at latitude: {latitude}, longitude: {longitude}, time: {current_time}")
            send_email(email_info, frame, latitude, longitude)
            last_write_time = time.time()
        if detected and time.time() - initial_detection_time >= 15:
            last_write_time = time.time()  
            initial_detection_time = None 
            detected = False 
        if cv2.waitKey(1) & 0xFF == ord('q'):
            break
    cap.release()
    cv2.destroyAllWindows()
def detect_objects_mobile_camera(model, source):
    location = geocoder.ip('me')
    latitude, longitude = location.latlng
    map_opened = False
    detected = False
    last_write_time = time.time()
    initial_detection_time = None
    # Change the source to the IP address of your mobile camera
    source = 'http://192.168.43.1:8080/video'
    cap = cv2.VideoCapture(source)
    while cap.isOpened():
        ret, frame = cap.read()
        if not ret:
            break
        results = model.predict(frame)
        for result in results:
            if result.boxes is not None and len(result.boxes.data) > 0: 
                confidence = result.boxes.conf[0] 
                if confidence > 0.7 and not detected: 
                    current_time = datetime.now().strftime("%H:%M:%S")
                    print(f"Object detected at latitude: {latitude}, longitude: {longitude}, time: {current_time}")
                    annotate_frame(frame, latitude, longitude)
                    if not map_opened:
                        open_google_maps(latitude, longitude)
                        map_opened = True
                    detected = True
                    initial_detection_time = time.time()
                    send_email(email_info, frame, latitude, longitude, source_type='MobileCamera')
                    make_phone_call(message) 
        cv2.imshow('Object Detection', frame)
        if detected and time.time() - last_write_time >= 15:
            st.write(f"Object detected at latitude: {latitude}, longitude: {longitude}, time: {current_time}")
            send_email(email_info, frame, latitude, longitude)
            last_write_time = time.time()
        if detected and time.time() - initial_detection_time >= 15:
            last_write_time = time.time()  
            initial_detection_time = None 
            detected = False 
        if cv2.waitKey(1) & 0xFF == ord('q'):
            break
    cap.release()
    cv2.destroyAllWindows()
def open_google_maps(latitude, longitude):
    google_maps_url = f"https://www.google.com/maps/search/?api=1&query={latitude},{longitude}"
    st.write(google_maps_url)
def annotate_frame(frame, latitude, longitude):
    cv2.putText(frame, f'Latitude: {latitude}, Longitude: {longitude}', 
                (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)
def cleanup_uploads_folder():
    folder_path = 'uploads'
    for filename in os.listdir(folder_path):
        file_path = os.path.join(folder_path, filename)
        try:
            if os.path.isfile(file_path) or os.path.islink(file_path):
                os.unlink(file_path)
            elif os.path.isdir(file_path):
                shutil.rmtree(file_path)
        except Exception as e:
            print('Failed to delete %s. Reason: %s' % (file_path, e))
def render_detection_page():
    st.sidebar.title('Choose Detection Type')
    detection_types = ['Accident Detection', 'Weapon Detection', 'Fall Detection', 'Fire Detection']
    detection_type = st.sidebar.selectbox("Select detection type:", detection_types)
    if detection_type != 'Select Detection Type':
        st.title(f'{detection_type}')
        st.image(get_logo_path(detection_type), width=200, use_column_width=False, caption='')
    model = load_model(detection_type)
    choice = st.selectbox("Choose 'Image' or 'Video':", ('Image', 'Video'))
    os.makedirs('uploads', exist_ok=True)
    source = None
    video_choice=None
    if choice == 'Video':
        video_choice = st.selectbox("Choose 'Webcam','MobileCamera','YouTube link', or 'Local video':", ('Webcam','MobileCamera', 'YouTube link', 'Local video'))
        if video_choice == 'Webcam':
            source = 0
        elif video_choice=='MobileCamera':
            source = 'http://192.168.43.1:8080/video'  
        elif video_choice == 'YouTube link':
            youtube_url = st.text_input("Enter YouTube video link: ")
            if youtube_url:
                video = YouTube(youtube_url)
                downloaded_file = video.streams.first().download(filename="downloaded_video")
                new_path = os.path.join('uploads', "downloaded_video.mp4")
                shutil.move(downloaded_file, new_path)
                source = new_path
        elif video_choice == 'Local video':
            uploaded_file = st.file_uploader("Choose a video file")
            if uploaded_file is not None:
                file_path = os.path.join('uploads', uploaded_file.name)
                with open(file_path, 'wb') as f:
                    f.write(uploaded_file.getbuffer())
                source = file_path
    else:
        image_choice = st.selectbox("Choose 'Local image' or 'Online image link':", ('Local image', 'Online image link'))
        if image_choice == 'Local image':
            uploaded_file = st.file_uploader("Choose an image file")
            if uploaded_file is not None:
                file_path = os.path.join('uploads', uploaded_file.name)
                with open(file_path, 'wb') as f:
                    f.write(uploaded_file.getbuffer())
                source = file_path
        elif image_choice == 'Online image link':
            image_url = st.text_input("Enter online image link: ")
            if image_url:
                response = requests.get(image_url)
                img = Image.open(BytesIO(response.content))
                img.save("downloaded_image.jpg")
                source = "downloaded_image.jpg"
    if st.button('Run Object Detection'):
        if model is not None and source is not None:
            if detection_type == 'Fire Detection':
                objects_detected = detect_fire_objects(model, source)
            elif video_choice=='Webcam':
                detect_objects_webcam(model)
            elif video_choice=='MobileCamera':
                detect_objects_mobile_camera(model, source) 
            else:
                objects_detected = detect_objects(model, choice, source)
                
            if st.button("Close"):
                st.empty()
            if objects_detected:
                display_popup("Objects detected!")
            else:
                display_popup("No objects detected.")
        elif source is None:
            st.warning("Please provide a source before running object detection.")
        else:
            st.warning("Model is not loaded. Please load the model before running object detection.")
    cleanup_uploads_folder()
def display_popup(message, duration=2):
    top_margin = "top: 50%;"
    left_margin = "left: 50%;"
    transform = "transform: translate(-50%, -50%);"
    with st.container():
        st.markdown(
            f"""
            <style>
            .popup-container {{
                position: fixed;
                {top_margin}
                {left_margin}
                {transform}
                background-color: rgba(255, 255, 255, 0.9);
                padding: 20px;
                border-radius: 10px;
                box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
                z-index: 9999;
            }}
            </style>
            """
        , unsafe_allow_html=True)
        st.markdown(f"<div class='popup-container'>{message}</div>", unsafe_allow_html=True)
def get_logo_path(detection_type):
    logos = {
        'Accident Detection':'https://www.creativefabrica.com/wp-content/uploads/2022/10/19/Crush-Car-Accident-Logo-Vector-Graphics-42314965-1.jpg',
        'Weapon Detection': 'https://www.scylla.ai/static/e2793aeaf61e498e681e1ad883411e45/614ca/thumb.png',
        'Fall Detection': 'https://classicalguitarshed.com/wp-content/uploads/2014/08/slipping-640.jpg',
        'Fire Detection': 'https://static.vecteezy.com/system/resources/previews/008/828/403/large_2x/real-estate-house-with-fire-flame-free-vector.jpg'
    }
    return logos.get(detection_type, 'https://b2b989d215c701ad63d7-288404e13f895703cf2798bf6ae95228.ssl.cf1.rackcdn.com/982251244256-350.png')
def render_instructions_page():
    st.title('Instructions')
    st.write("Welcome to the Object Detection App!")
    st.subheader("Getting Started:")
    st.write("1. Navigate to the 'Detection' page using the sidebar.")
    st.write("2. Choose the type of detection you want to perform from the dropdown menu.")
    st.write("3. Select whether you want to analyze an image or a video.")
    st.subheader("For Video Detection:")
    st.write("- Choose between 'Webcam','MobileCamera', 'YouTube link,' or 'Local video.'")
    st.write("- Provide the necessary input (e.g., YouTube link or upload a local video file).")
    st.subheader("For Image Detection:")
    st.write("- Choose between 'Local image' or 'Online image link.'")
    st.write("- Upload a local image file or provide the link for an online image.")
    st.subheader("Running Object Detection:")
    st.write("1. After selecting the detection type and input, click the 'Run Object Detection' button.")
    st.write("2. Wait for the results to be displayed.")
    st.write("Follow the steps on the sidebar to navigate between different pages.")
    st.write("Choose 'Accident Detection' or 'Weapon Detection' to get started.")
def render_safety_rules_page():
    st.title('Safety Rules')
    st.subheader("Safety Rules for Object Detection:")
    st.write("1. *Accident Detection:*")
    st.write("- Always prioritize the safety of individuals involved in accidents.")
    st.write("- Use the information provided by the model to inform emergency services, if necessary.")
    st.write("2. *Weapon Detection:*")
    st.write("- This tool is not a substitute for professional security measures.")
    st.write("- In case of any threat, contact law enforcement immediately.")
    st.write("3. *Fall Detection:*")
    st.write("- The fall detection results are for informational purposes.")
    st.write("- For actual assistance, contact medical professionals or emergency services.")
    st.write("4. *Fire Detection:*")
    st.write("- If a fire is detected, follow appropriate safety protocols.")
    st.write("- Contact the fire department and evacuate the premises if necessary.")
def main():
    st.set_page_config(page_title="Object Detection App", page_icon=":camera:")
    st.sidebar.title('Object Detection App')
    page = st.sidebar.selectbox("Select a page:", ["Instructions", "Detection", "Safety Rules"])
    if page == "Instructions":
        render_instructions_page()
        st.sidebar.image('https://th.bing.com/th/id/OIG4.6TZvDqdCelBdGqpZIjEJ?pid=ImgGn', use_column_width=True)
    elif page == "Detection":
        render_detection_page()
        st.sidebar.image('https://th.bing.com/th/id/OIG4.6TZvDqdCelBdGqpZIjEJ?pid=ImgGn', use_column_width=True)
    elif page == "Safety Rules":
        render_safety_rules_page()
        st.sidebar.image('https://th.bing.com/th/id/OIG4.6TZvDqdCelBdGqpZIjEJ?pid=ImgGn', use_column_width=True)
if __name__ == "__main__":
    main()